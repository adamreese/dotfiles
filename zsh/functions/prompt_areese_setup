# vim: ft=zsh :

NEWLINE='
'

GIT_PROMPT_DIRTY="%F{blue}[!]%f "
GIT_PROMPT_DETACHED="detached"
GIT_PROMPT_UNCOMMITTED="+"
GIT_PROMPT_UNSTAGED="!"
GIT_PROMPT_UNTRACKED="?"
GIT_PROMPT_UNPULLED="↓"
GIT_PROMPT_UNPUSHED="↑"

prompt_git() {
  # Check if the current directory is in a Git repository.
  command git rev-parse --is-inside-work-tree &>/dev/null || return

  # local branch=$(vcs_info_msg_0_)
  local branch=$(prompt_filthy_git_branch)
  local repo_status="$(parse_git_dirty)$(parse_git_unpushed_unpulled)"
  local repo_status=$(prompt_filthy_git_repo_status)

  echo -n "%F{white}on %F{blue}${branch}${repo_status}%f"
}

parse_git_dirty() {
  local dirty=''
  dirty=$(command git status --porcelain 2> /dev/null | tail -n1)
  if [[ -n $dirty ]]; then
    echo "${GIT_PROMPT_DIRTY}"
  fi
}

# Unpushed and unpulled commits.
# Get unpushed and unpulled commits from remote and draw arrows.
parse_git_unpushed_unpulled() {
  # check if there is an upstream configured for this branch
  command git rev-parse --abbrev-ref @'{u}' &>/dev/null || return

  local count
  count="$(command git rev-list --left-right --count HEAD...@'{u}' 2>/dev/null)"
  # exit if the command failed
  (( !$? )) || return

  # counters are tab-separated, split on tab and store as array
  count=(${(ps:\t:)count})
  local arrows left=${count[1]} right=${count[2]}

  (( ${right:-0} > 0 )) && arrows+="${GIT_PROMPT_UNPULLED}"
  (( ${left:-0} > 0 )) && arrows+="${GIT_PROMPT_UNPUSHED}"

  [ -n $arrows ] && echo -n "${arrows}"
}

prompt_filthy_git_repo_status() {

  # # set GIT_TERMINAL_PROMPT=0 to disable auth prompting for git fetch (git 2.3+)
  # export GIT_TERMINAL_PROMPT=0
  # # set ssh BachMode to disable all interactive ssh password prompting
  # export GIT_SSH_COMMAND=${GIT_SSH_COMMAND:-"ssh -o BatchMode=yes"}

  # # Do a fetch asynchronously
  # command git -c gc.auto=0 fetch &>/dev/null &!

  local dirty count up down rtn=""

  dirty=$(command git status --porcelain 2> /dev/null | tail -n1)

  [[ $dirty != "" ]] && rtn+=" ${GIT_PROMPT_DIRTY}"

  # check if there is an upstream configured for this branch
  # exit if there isn't, as we can't check for remote changes
  if command git rev-parse --abbrev-ref @'{u}' &>/dev/null; then
    # if there is, check git left and right arrow_status
    count="$(command git rev-list --left-right --count HEAD...@'{u}' 2>/dev/null)"

    # Get the push and pull counts
    up="$count[(w)1]"
    down="$count[(w)2]"

    # Check if either push or pull is needed
    [[ $up > 0 || $down > 0 ]] && rtn+=" "

    # Push is needed, show up arrow
    [[ $up > 0 ]] && rtn+="${GIT_PROMPT_UNPUSHED}"

    # Pull is needed, show down arrow
    [[ $down > 0 ]] && rtn+="${GIT_PROMPT_UNPULLED}"
  fi

  print $rtn
}

prompt_filthy_git_branch() {
  # get the current git status
  local branch git_dir_local rtn

  branch=$(git status --short --branch -uno --ignore-submodules=all | head -1 | awk '{print $2}' 2>/dev/null)
  git_dir_local=$(git rev-parse --git-dir)

  # remove reference to any remote tracking branch
  branch=${branch%...*}

  # check if HEAD is detached
  if [[ -d "${git_dir_local}/rebase-merge" ]]; then
    branch=$(git status | head -5 | tail -1 | awk '{print $6}')
    rtn="%F{red}rebasing interactively%f%F{242} → ${branch//([[:space:]]|\')/}%f"
  elif [[ -d "${git_dir_local}/rebase-apply" ]]; then
    branch=$(git status | head -2 | tail -1 | awk '{print $6}')
    rtn="%F{red}rebasing%f%F{242} → ${branch//([[:space:]]|\')/}%f"
  elif [[ -f "${git_dir_local}/MERGE_HEAD" ]]; then
    branch=$(git status | head -1 | awk '{print $3}')
    rtn="%F{red}merging%f%F{242} → ${branch//([[:space:]]|\')/}%f"
  elif [[ "$branch" = "HEAD" ]]; then
    commit=$(git status HEAD -uno --ignore-submodules=all | head -1 | awk '{print $4}' 2>/dev/null)

    if [[ "$commit" = "on" ]]; then
      rtn="%F{yellow}no branch%f"
    else
      rtn="${GIT_PROMPT_DETACHED} "
      rtn+="%F{white}"
      rtn+="${commit}"
      rtn+="%f"
    fi
  else
    rtn="%F{blue}$branch%f"
  fi

  print "$rtn"
}

prompt_status() {
  echo -n "%(?.%F{003}.%F{red})❯%f "
}

prompt_dir() {
  local git_root current_path rtn
  if command git rev-parse --is-inside-work-tree &>/dev/null; then
    # Print the name of the repository
    git_root=$(command git rev-parse --show-toplevel 2>/dev/null)
    rtn="${git_root##*/}"

    # Print the current_path relative to the git root
    current_path=${$(git rev-parse --show-prefix)%/}
    if [[ -n "${current_path}" ]]; then
      rtn+="/${current_path}"
    fi
  else
    rtn="%~%u"
  fi
  print -n "%F{green}${rtn}%f "
}

areese_prompt() {
  echo -n "$NEWLINE"

  prompt_dir
  prompt_git
  echo -n "$NEWLINE"
  prompt_status
}

prompt_areese_precmd() {
  # vcs_info
  PROMPT='$(areese_prompt)'
}

prompt_areese_setup() {
  autoload -Uz add-zsh-hook
  # autoload -Uz vcs_info

  add-zsh-hook precmd prompt_areese_precmd

  prompt_opts=(cr subst percent)

  # zstyle ':vcs_info:*' enable git
  # zstyle ':vcs_info:*' check-for-changes false
  # zstyle ':vcs_info:git*' formats '%b '
  # zstyle ':vcs_info:git*' actionformats '%b|%a '
}

prompt_areese_setup "$@"

# ------------------------------------------------------------------------------
# vim:ft=zsh
